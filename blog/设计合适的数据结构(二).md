title: 设计合适的数据结构(二)
date: 2015-04-03 15:28:31
categories: 基础知识
tags: 数据结构
---

## 问题背景
>设计实现一个抽象数据类型，能支持下列操作：
>
>- insert(x)：如果x不在数据结构中，则插入x
>- delete(x)：从数据结构中删除x（如果x存在）
>- find_next(x)：在数据结构中搜索比x大的最小关键字
>
>所有这些操作在最坏情况下的复杂度要求为O(log n)，其中n是数据结构中元素的个数。

<!-- more -->

分析：上面的insert和delete这两个操作都需要先在数据结构中查找x。查找如果要控制在O(log n)的时间复杂度的话一般就是二叉搜索树和二分查找，但是二分查找需要基于有序线性表，所以不一定可以。

### 树
对于二叉搜索树需要注意其退化成链表的情况（这样就不能保证O(log n)的时间复杂度了），此时需要加上平衡算法。如何保持二叉树的节点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除节点的策略。关于二叉搜索树及相关的平衡树（AVL树，红黑树等）可以参考[这篇博文](http://blog.csdn.net/chlele0105/article/details/8473846)。

### 跳表
如果不使用树，其实还可以使用跳表，同样可以把插入删除的时间复杂度控制在O(log n)，至于查找比x大的最小关键字也不难在O(log n)时间内找到。关于跳表，这里就不展开描述了（其实让我描述也说不清楚 = = ），同样，推荐文章给大家看：[这篇](http://kenby.iteye.com/blog/1187303)和[这篇](http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html)。

### 放弃数组或者链表
如果想使用二分查找，那么首先数据结构必须是有序的线性表。如此一来，那么插入和删除的时候要做到O(log n)就比较困难了，因为如果选择数组作为底层存储的话，虽然查找可以做到O(log n)，但是插入和删除的时间复杂度是O(n)。如果选择链表，那二分查找本身就做不到O(log n)的时间复杂度了，即使插入和删除是O(1)也无济于事。

### 其他方案
还有没有其他的方法呢，不会只有BST一类的和跳表这两种吧。。。

## 扩展问题一
>insert和delete函数要求不变，第三个方法改成实现find_smallest(k)：在数据结构中搜索第k小的关键字。所有这些操作在最坏情况下的复杂度要求为O(log n)。

PS：可以使用AVL树，在每个节点上增加一个数据域：存放这个节点的子节点的个数（包括自己）。

## 扩展问题二
>insert和delete函数要求不变，第三个方法改成实现find_next(x,k)：在数据结构中把比x大的关键字从小到大排序，搜索第k个这样的关键字。所有这些操作在最坏情况下的复杂度要求为O(log n)。


## 参考资料

- [B树、B+树、AVL树、红黑树](http://blog.csdn.net/chlele0105/article/details/8473846)
- [跳表SkipList](http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html)
- [SkipList跳表](http://kenby.iteye.com/blog/1187303)


