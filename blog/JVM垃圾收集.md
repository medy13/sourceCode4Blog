title: JVM垃圾收集
date: 2014-05-20 10:17:16
categories: Java
toc: true
---
## 内存回收的三个问题
* What
* When
* How

### WHAT
程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，也就是生命周期与线程一样。这几个区域的内存分配和回收不需考虑太多，因为随着方法的结束，内存自然就回收了。

所以内存回收关注的重点就是：``Java堆``和``方法区``。

<!-- more -->

### WHEN
#### 栈
当方法执行完毕，该栈帧就自行销毁。
#### 堆
Java堆应该什么时候回收呢，或者是当堆中的对象达到什么条件就应该被回收呢？

* 当对象的引用数为0时回收

给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加一；当引用失效时，计数器值就减一；任何时刻，计数器为0的对象就是不可能再被使用的。也就是应该被回收的对象。

先声明一下，Java不是这么做的。
微软的COM、FlashPlayer、Python、Squirrel是采用的这种方法。
缺点：很难解决对象间的循环引用问题。

* 对象不可到达时被回收
主流的商用程序语言（Java、C#、甚至是Lisp）都是采用的根搜索算法（GC Roots Tracing）判断对象是否存活。

根搜索算法的基本思路是：有一系列的称之为 **GC Roots** 的对象，从这些对象出发，向下搜索，搜索走过的路径称为**引用链**（Reference Chain），当一个对象到GC Roots不可达时（即不存在能将该对象链接到GC Roots的引用链），这个对象就是应该被回收。

>什么对象才能加入GC Roots阵营呢？
>
>* 虚拟机栈（其实是栈帧中的本地变量表）中的引用的对象。
>* 第二种：方法区中类静态属性引用的对象。
>* 第三种：方法区中的常量引用的对象。
>* 第四种：本地方法栈中的JNI（也就是Native方法）的引用的对象。（对照虚拟机栈用本地方法栈的诸多相似点，本条同第一条其实也是类似的，虚拟机栈同本地方法栈真是一对好基友。）

在根搜索算法中，真正宣告一个对象死亡，至少要经历两次标记过程。

#### 方法区
在方法区进行垃圾收集的性价比一般比较低。主要回收：废弃常量和无用的类。

* 回收废弃常量。
>
>回收废弃常量类似回收Java堆中的对象，以常量池中的字符串回收为例：加入一个字符串“abc”已经进入常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，如果这个时候发生内存回收，而且必要的话，这个“abc”就会被回收。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

* 回收无用的类

>当一个类满足以下的三个条件才算是“无用的类”
>
>* 该类所有的实例都已经回收，Java堆中不存在任何该类的实例
>* 加载该类的ClassLoader已经被回收
>* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述三个条件的无用类进行回收，用*可以*是因为并不是不用了就会对其回收。虚拟机会在需要的时候进行回收。

>在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，保证方法区不会溢出。 

### HOW
#### 垃圾回收算法
##### 标记-清除算法

Mark-Sweep：先标记所有需要回收对象，然后统一回收。

问题

- 效率问题，标记和清除两个过程的效率都不高。
- 空间问题，会产生大量不连续的内存碎片。分配大对象时容易提前触发GC。

##### 复制算法

Copying：把可用内存分为大小相等的两块，每次只使用一块。当一块用完时，将存活对象复制到另一块，再一次清理掉已使用的内存块。

实现简单，分配快，只需要顺序移动堆顶指针就可以进行分配，允许高效。代价是内存浪费大。

IBM的研究表明，新产生的对象98%都是很快就死忙的。

HotSpot将内存分为一块较大的Eden和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时，将Eden和Survivor中存活的对象一次性复制到另一个Survivor上，然后清理掉Eden和用过的Survivor。

在上面的复制过程中，如果Survivor空间不够，则需要引入一种分配担保机制来处理，在HotSpot中是将对象分配到年老代。

##### 标记-压缩

Mark-Compact：先标记，然后将存活对象移向一边，再清理掉边界以外的内存。

##### 分代收集算法

- 一般的虚拟机都是分代收集算法，也就是把内存分为几个块，不同的块用不同的回收算法。

- 一般将内存分为新生代和年老代，在新生代一般采用复制算法，年老代采用标记-压缩算法。

## 几种垃圾收集器
- Serial串行GC收集器
- ParNew并行GC收集器
- Parallel Scavenge并行回收GC收集器
- Serial Old串行GC收集器
- Parallel Old并行GC收集器
- CMS并发GC收集器
- G1收集器

这里推荐大家看周志明的《深入理解Java虚拟机》的第3.4节。[这篇博文](http://blog.csdn.net/java2000_wl/article/details/8030172)大概描述了各个垃圾收集器，包括他们使用了何种算法，是单线程、还是支持并行、并发的。[这篇文章](http://www.importnew.com/15311.html)较详细的介绍了G1垃圾收集器。

## 参考资料
- 周志明 《深入理解Java虚拟机》
- [Java虚拟机学习 - 垃圾收集器](http://blog.csdn.net/java2000_wl/article/details/8030172)
- [JVM中的G1垃圾回收器](http://www.importnew.com/15311.html)